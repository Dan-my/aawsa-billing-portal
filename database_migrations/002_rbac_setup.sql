-- Create roles table
CREATE TABLE IF NOT EXISTS public.roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name TEXT NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.roles IS 'Stores user roles for role-based access control.';

-- Create permissions table
CREATE TABLE IF NOT EXISTS public.permissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    category TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.permissions IS 'Stores individual permissions that can be assigned to roles.';
COMMENT ON COLUMN public.permissions.category IS 'A category for grouping permissions in the UI, e.g., "User Management".';

-- Create role_permissions join table
CREATE TABLE IF NOT EXISTS public.role_permissions (
    role_id BIGINT NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
    permission_id BIGINT NOT NULL REFERENCES public.permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.role_permissions IS 'Links roles to their assigned permissions.';

-- Add the role_id column to staff_members if it doesn't exist
-- This ensures the relationship between staff and roles can be established.
ALTER TABLE public.staff_members ADD COLUMN IF NOT EXISTS role_id BIGINT;

-- Add the foreign key constraint to link staff_members to roles
-- This is the critical fix for the login issue.
ALTER TABLE public.staff_members
DROP CONSTRAINT IF EXISTS staff_members_role_id_fkey,
ADD CONSTRAINT staff_members_role_id_fkey
FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE SET NULL;
COMMENT ON COLUMN public.staff_members.role_id IS 'Foreign key to the roles table.';


-- Insert default roles, ignoring if they already exist
INSERT INTO public.roles (role_name, description) VALUES
('Admin', 'Full access to all system features and settings.'),
('Staff', 'Access limited to managing data within their assigned branch.'),
('Head Office Management', 'Read-only access to all data and full access to reporting.'),
('Staff Management', 'Manages staff and branches, plus standard staff duties.')
ON CONFLICT (role_name) DO NOTHING;

-- Insert permissions, ignoring if they already exist
INSERT INTO public.permissions (name, category, description) VALUES
('dashboard_view_all', 'Dashboard', 'View dashboard with data from all branches'),
('dashboard_view_branch', 'Dashboard', 'View dashboard with data limited to assigned branch'),
('branches_view', 'Branch Management', 'View all branches'),
('branches_create', 'Branch Management', 'Create new branches'),
('branches_update', 'Branch Management', 'Update existing branches'),
('branches_delete', 'Branch Management', 'Delete branches'),
('staff_view', 'Staff Management', 'View all staff members'),
('staff_create', 'Staff Management', 'Create new staff members'),
('staff_update', 'Staff Management', 'Update staff member details and roles'),
('staff_delete', 'Staff Management', 'Delete staff members'),
('notifications_view', 'Notifications', 'View sent notification history'),
('notifications_create', 'Notifications', 'Send notifications to staff'),
('tariffs_view', 'Tariff Management', 'View tariff rates and settings'),
('tariffs_update', 'Tariff Management', 'Update tariff rates and settings'),
('bulk_meters_view_all', 'Bulk Meter Management', 'View all bulk meters across all branches'),
('bulk_meters_view_branch', 'Bulk Meter Management', 'View bulk meters within assigned branch'),
('bulk_meters_create', 'Bulk Meter Management', 'Create new bulk meters'),
('bulk_meters_update', 'Bulk Meter Management', 'Update existing bulk meters'),
('bulk_meters_delete', 'Bulk Meter Management', 'Delete bulk meters'),
('customers_view_all', 'Customer Management', 'View all customers across all branches'),
('customers_view_branch', 'Customer Management', 'View customers within assigned branch'),
('customers_create', 'Customer Management', 'Create new customers'),
('customers_update', 'Customer Management', 'Update existing customers'),
('customers_delete', 'Customer Management', 'Delete customers'),
('data_entry_access', 'Data Entry', 'Access the data entry forms (manual and CSV)'),
('meter_readings_view_all', 'Meter Readings', 'View all meter readings across all branches'),
('meter_readings_view_branch', 'Meter Readings', 'View meter readings within assigned branch'),
('meter_readings_create', 'Meter Readings', 'Add new meter readings'),
('reports_generate_all', 'Reporting', 'Generate and download reports for all branches'),
('reports_generate_branch', 'Reporting', 'Generate and download reports for assigned branch'),
('settings_view', 'System Settings', 'View application settings'),
('settings_update', 'System Settings', 'Update application settings'),
('permissions_view', 'Permissions', 'View roles and permissions'),
('permissions_update', 'Permissions', 'Update role permissions')
ON CONFLICT (name) DO NOTHING;

-- Function to update role permissions transactionally
-- IMPORTANT: SECURITY DEFINER allows this function to modify the role_permissions table
-- even when called by a user who doesn't have direct write access,
-- which is necessary for the application to work correctly.
CREATE OR REPLACE FUNCTION public.update_role_permissions(p_role_id bigint, p_permission_ids bigint[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = public
AS $function$
BEGIN
    -- This function runs with the privileges of the user who defined it (the owner).
    
    -- Delete all existing permissions for the specified role first.
    DELETE FROM public.role_permissions WHERE role_id = p_role_id;

    -- Insert the new set of permissions for the role.
    -- If the input array is empty or null, this will do nothing, effectively
    -- removing all permissions for the role.
    IF p_permission_ids IS NOT NULL AND array_length(p_permission_ids, 1) > 0 THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        SELECT p_role_id, permission_id
        FROM unnest(p_permission_ids) AS t(permission_id);
    END IF;

END;
$function$;

-- The initial assignment of permissions is only done if the role_permissions table is empty,
-- to avoid overwriting any custom changes made by the administrator.
DO $$
DECLARE
    admin_role_id BIGINT;
    staff_role_id BIGINT;
    head_office_role_id BIGINT;
    staff_mgmt_role_id BIGINT;
    permission_count INTEGER;
BEGIN
    SELECT count(*) INTO permission_count FROM role_permissions;
    
    IF permission_count = 0 THEN
        -- Get role IDs
        SELECT id INTO admin_role_id FROM roles WHERE role_name = 'Admin';
        SELECT id INTO staff_role_id FROM roles WHERE role_name = 'Staff';
        SELECT id INTO head_office_role_id FROM roles WHERE role_name = 'Head Office Management';
        SELECT id INTO staff_mgmt_role_id FROM roles WHERE role_name = 'Staff Management';

        -- Assign all permissions to Admin
        INSERT INTO role_permissions (role_id, permission_id)
        SELECT admin_role_id, id FROM permissions;

        -- Assign permissions for Staff
        INSERT INTO role_permissions (role_id, permission_id)
        SELECT staff_role_id, id FROM permissions WHERE name IN (
            'dashboard_view_branch', 'bulk_meters_view_branch', 'bulk_meters_create', 'bulk_meters_update',
            'bulk_meters_delete', 'customers_view_branch', 'customers_create', 'customers_update',
            'customers_delete', 'data_entry_access', 'meter_readings_view_branch', 'meter_readings_create',
            'reports_generate_branch'
        );

        -- Assign permissions for Head Office Management
        INSERT INTO role_permissions (role_id, permission_id)
        SELECT head_office_role_id, id FROM permissions WHERE name IN (
            'dashboard_view_all', 'branches_view', 'staff_view', 'notifications_view', 'tariffs_view',
            'bulk_meters_view_all', 'customers_view_all', 'meter_readings_view_all', 'reports_generate_all',
            'settings_view'
        );
        
        -- Assign permissions for Staff Management
        INSERT INTO role_permissions (role_id, permission_id)
        SELECT staff_mgmt_role_id, id FROM permissions WHERE name IN (
            'dashboard_view_branch', 'bulk_meters_view_branch', 'bulk_meters_create', 'bulk_meters_update',
            'bulk_meters_delete', 'customers_view_branch', 'customers_create', 'customers_update',
            'customers_delete', 'data_entry_access', 'meter_readings_view_branch', 'meter_readings_create',
            'reports_generate_branch', 'branches_view', 'branches_create', 'branches_update', 'staff_view',
            'staff_create', 'staff_update', 'staff_delete', 'notifications_create', 'notifications_view'
        );
    END IF;
END $$;

-- ====== START: ROW-LEVEL SECURITY POLICIES ======

-- Helper function to check for Admin role.
-- NOTE: This relies on your app eventually using Supabase Auth, where auth.uid() matches staff_members.id
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.staff_members
    WHERE id = auth.uid() AND role_id = (SELECT id FROM public.roles WHERE role_name = 'Admin' LIMIT 1)
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Enable RLS on all three tables
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to ensure a clean slate
DROP POLICY IF EXISTS "Allow authenticated users to read roles" ON public.roles;
DROP POLICY IF EXISTS "Allow Admins to manage roles" ON public.roles;
DROP POLICY IF EXISTS "Allow authenticated users to read permissions" ON public.permissions;
DROP POLICY IF EXISTS "Allow Admins to manage permissions" ON public.permissions;
DROP POLICY IF EXISTS "Allow authenticated users to read their permissions" ON public.role_permissions;
DROP POLICY IF EXISTS "Disallow direct modification of role_permissions" ON public.role_permissions;

-- Policies for 'roles' table
CREATE POLICY "Allow authenticated users to read roles" ON public.roles FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow Admins to manage roles" ON public.roles FOR ALL TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Policies for 'permissions' table
CREATE POLICY "Allow authenticated users to read permissions" ON public.permissions FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow Admins to manage permissions" ON public.permissions FOR ALL TO authenticated USING (public.is_admin()) WITH CHECK (public.is_admin());

-- Policies for 'role_permissions' table
CREATE POLICY "Allow authenticated users to read their permissions" ON public.role_permissions FOR SELECT TO authenticated USING (true);
CREATE POLICY "Disallow direct modification of role_permissions" ON public.role_permissions FOR ALL TO authenticated USING (false) WITH CHECK (false);

-- ====== END: ROW-LEVEL SECURITY POLICIES ======
