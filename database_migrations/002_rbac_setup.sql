-- ========= Section 1: Core RBAC Table Setup =========

CREATE TABLE IF NOT EXISTS public.roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name TEXT NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.permissions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    category TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.role_permissions (
    role_id BIGINT NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
    permission_id BIGINT NOT NULL REFERENCES public.permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add the role_id column to staff_members if it doesn't exist
ALTER TABLE public.staff_members ADD COLUMN IF NOT EXISTS role_id BIGINT;

-- Add the foreign key constraint to link staff_members to roles
ALTER TABLE public.staff_members
DROP CONSTRAINT IF EXISTS staff_members_role_id_fkey,
ADD CONSTRAINT staff_members_role_id_fkey
FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE SET NULL;

-- ========= Section 2: Helper Functions for RLS =========

-- Helper function to check if the current user has a specific permission.
-- NOTE: This relies on Supabase Auth, where auth.uid() matches staff_members.id
CREATE OR REPLACE FUNCTION public.user_has_permission(p_permission_name TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  user_role_id BIGINT;
  has_perm BOOLEAN;
BEGIN
  -- Get the role_id from the staff_members table based on the logged-in user's ID
  SELECT role_id INTO user_role_id
  FROM public.staff_members
  WHERE id = auth.uid()
  LIMIT 1;
  
  -- If the user has no role, they have no permissions.
  IF user_role_id IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Check if a record exists linking the user's role to the requested permission.
  SELECT EXISTS (
    SELECT 1
    FROM public.role_permissions rp
    JOIN public.permissions p ON rp.permission_id = p.id
    WHERE rp.role_id = user_role_id AND p.name = p_permission_name
  ) INTO has_perm;
  
  RETURN has_perm;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ========= Section 3: RLS Policies for RBAC Tables =========

-- Enable RLS on all three tables
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to ensure a clean slate
DROP POLICY IF EXISTS "Allow public read access" ON public.roles;
DROP POLICY IF EXISTS "Allow admin modification" ON public.roles;
DROP POLICY IF EXISTS "Allow public read access" ON public.permissions;
DROP POLICY IF EXISTS "Allow admin modification" ON public.permissions;
DROP POLICY IF EXISTS "Allow public read access" ON public.role_permissions;
DROP POLICY IF EXISTS "Disallow direct modification" ON public.role_permissions;

-- Policies for 'roles' table
CREATE POLICY "Allow public read access" ON public.roles FOR SELECT USING (true);
CREATE POLICY "Allow admin modification" ON public.roles FOR ALL USING (user_has_permission('permissions_update')) WITH CHECK (user_has_permission('permissions_update'));

-- Policies for 'permissions' table
CREATE POLICY "Allow public read access" ON public.permissions FOR SELECT USING (true);
CREATE POLICY "Allow admin modification" ON public.permissions FOR ALL USING (user_has_permission('permissions_update')) WITH CHECK (user_has_permission('permissions_update'));

-- Policies for 'role_permissions' table
CREATE POLICY "Allow public read access" ON public.role_permissions FOR SELECT USING (true);
CREATE POLICY "Disallow direct modification" ON public.role_permissions FOR ALL USING (false) WITH CHECK (false);


-- ========= Section 4: Initial Data Seeding (if necessary) =========

-- Insert default roles, ignoring if they already exist
INSERT INTO public.roles (role_name, description) VALUES
('Admin', 'Full access to all system features and settings.'),
('Staff', 'Access limited to managing data within their assigned branch.'),
('Head Office Management', 'View-oriented role with access to all data and reporting.'),
('Staff Management', 'Manages staff and branches, plus standard staff duties.')
ON CONFLICT (role_name) DO NOTHING;

-- Insert permissions, ignoring if they already exist
INSERT INTO public.permissions (name, category, description) VALUES
('dashboard_view_all', 'Dashboard', 'View dashboard with data from all branches'),
('dashboard_view_branch', 'Dashboard', 'View dashboard with data limited to assigned branch'),
('branches_view', 'Branch Management', 'View all branches'),
('branches_create', 'Branch Management', 'Create new branches'),
('branches_update', 'Branch Management', 'Update existing branches'),
('branches_delete', 'Branch Management', 'Delete branches'),
('staff_view', 'Staff Management', 'View all staff members'),
('staff_create', 'Staff Management', 'Create new staff members'),
('staff_update', 'Staff Management', 'Update staff member details and roles'),
('staff_delete', 'Staff Management', 'Delete staff members'),
('notifications_view', 'Notifications', 'View sent notification history'),
('notifications_create', 'Notifications', 'Send notifications to staff'),
('tariffs_view', 'Tariff Management', 'View tariff rates and settings'),
('tariffs_update', 'Tariff Management', 'Update tariff rates and settings'),
('bulk_meters_view_all', 'Bulk Meter Management', 'View all bulk meters across all branches'),
('bulk_meters_view_branch', 'Bulk Meter Management', 'View bulk meters within assigned branch'),
('bulk_meters_create', 'Bulk Meter Management', 'Create new bulk meters'),
('bulk_meters_update', 'Bulk Meter Management', 'Update existing bulk meters'),
('bulk_meters_delete', 'Bulk Meter Management', 'Delete bulk meters'),
('customers_view_all', 'Customer Management', 'View all customers across all branches'),
('customers_view_branch', 'Customer Management', 'View customers within assigned branch'),
('customers_create', 'Customer Management', 'Create new customers'),
('customers_update', 'Customer Management', 'Update existing customers'),
('customers_delete', 'Customer Management', 'Delete customers'),
('data_entry_access', 'Data Entry', 'Access the data entry forms (manual and CSV)'),
('meter_readings_view_all', 'Meter Readings', 'View all meter readings across all branches'),
('meter_readings_view_branch', 'Meter Readings', 'View meter readings within assigned branch'),
('meter_readings_create', 'Meter Readings', 'Add new meter readings'),
('reports_generate_all', 'Reporting', 'Generate and download reports for all branches'),
('reports_generate_branch', 'Reporting', 'Generate and download reports for assigned branch'),
('settings_view', 'System Settings', 'View application settings'),
('settings_update', 'System Settings', 'Update application settings'),
('permissions_view', 'Permissions', 'View roles and permissions'),
('permissions_update', 'Permissions', 'Update role permissions')
ON CONFLICT (name) DO NOTHING;

-- Function to update role permissions transactionally
CREATE OR REPLACE FUNCTION public.update_role_permissions(p_role_id bigint, p_permission_ids bigint[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path = public
AS $function$
BEGIN
    DELETE FROM public.role_permissions WHERE role_id = p_role_id;
    IF p_permission_ids IS NOT NULL AND array_length(p_permission_ids, 1) > 0 THEN
        INSERT INTO public.role_permissions (role_id, permission_id)
        SELECT p_role_id, permission_id
        FROM unnest(p_permission_ids) AS t(permission_id);
    END IF;
END;
$function$;

-- Initial permission assignment (only if table is empty)
DO $$
DECLARE
    admin_role_id BIGINT;
    staff_role_id BIGINT;
    head_office_role_id BIGINT;
    staff_mgmt_role_id BIGINT;
    permission_count INTEGER;
BEGIN
    SELECT count(*) INTO permission_count FROM role_permissions;
    IF permission_count = 0 THEN
        SELECT id INTO admin_role_id FROM roles WHERE role_name = 'Admin';
        SELECT id INTO staff_role_id FROM roles WHERE role_name = 'Staff';
        SELECT id INTO head_office_role_id FROM roles WHERE role_name = 'Head Office Management';
        SELECT id INTO staff_mgmt_role_id FROM roles WHERE role_name = 'Staff Management';
        
        -- Assign all permissions to Admin
        INSERT INTO role_permissions (role_id, permission_id) SELECT admin_role_id, id FROM permissions;
        
        -- Assign permissions for Staff
        INSERT INTO role_permissions (role_id, permission_id) SELECT staff_role_id, id FROM permissions WHERE name IN ('dashboard_view_branch', 'bulk_meters_view_branch', 'bulk_meters_create', 'bulk_meters_update', 'bulk_meters_delete', 'customers_view_branch', 'customers_create', 'customers_update', 'customers_delete', 'data_entry_access', 'meter_readings_view_branch', 'meter_readings_create', 'reports_generate_branch');
        
        -- Assign permissions for Head Office Management (Corrected based on image)
        INSERT INTO role_permissions (role_id, permission_id) SELECT head_office_role_id, id FROM permissions WHERE name IN ('dashboard_view_all', 'branches_view', 'staff_view', 'tariffs_view', 'bulk_meters_view_all', 'customers_view_all', 'meter_readings_view_all', 'reports_generate_all');
        
        -- Assign permissions for Staff Management
        INSERT INTO role_permissions (role_id, permission_id) SELECT staff_mgmt_role_id, id FROM permissions WHERE name IN ('dashboard_view_branch', 'bulk_meters_view_branch', 'bulk_meters_create', 'bulk_meters_update', 'bulk_meters_delete', 'customers_view_branch', 'customers_create', 'customers_update', 'customers_delete', 'data_entry_access', 'meter_readings_view_branch', 'meter_readings_create', 'reports_generate_branch', 'branches_view', 'branches_create', 'branches_update', 'staff_view', 'staff_create', 'staff_update', 'staff_delete', 'notifications_create', 'notifications_view');
    END IF;
END $$;
